#### 顶点覆盖&独立集&路径覆盖

##### 顶点覆盖： 在顶点集合中，选取一部分顶点，这些顶点能够把所有的边都覆盖了。这些点就是顶点覆盖集                     最小顶点覆盖：在所有的顶点覆盖集中，顶点数最小的那个叫最小顶点集合。 

##### 独立集： 在所有的顶点中选取一些顶点，这些顶点两两之间没有连线，这些点就叫独立集                                                                                                       最大独立集： 在左右的独立集中，顶点数最多的那个集合 

##### 路径覆盖： 在图中找一些路径，这些路径覆盖图中所有的顶点，每个顶点都只与一条路径相关联。                                        最小路径覆盖：  在所有的路径覆盖中，路径个数最小的就是最小路径覆盖了。  



#### 在二分图中： 最大匹配 = 最小顶点覆盖

##### 首先证明，在最大匹配中，每条匹配边连接的两个顶点a,b最多只有一个与非匹配点有连边。              用反证法：假设a与c，b与d这件都有边，且c，d都不是匹配点，则可以去掉连接a,b的匹配边，加上连接a,c和连接b,d的匹配边，是匹配数+1，这与最大匹配矛盾。这样，我们构造这样一个顶点集合：对于每条匹配边，选择其连接的两个点中的一个（如果两个点有与非匹配点有连边的点，则选那个点；否则随便选一个）。

##### 这个集合中有最大匹配数个点，我们证明：这个点集能覆盖所有的边。                                                  若一条边是匹配边，则其显然被覆盖，若一条边不是匹配边：                                                               1）若其与某匹配顶点有连边，则该匹配顶点必在我们构造的点集中，所以该边被覆盖                        2）若其连接着两个非匹配点，则可以增加这条边为匹配边，是匹配数+1，这与最大匹配矛盾，故此情况不成立          

##### 而匹配的这m条边又是没有公共交点的, 所以一个顶点覆盖至少需要m个点；                                                           综上： 最大匹配数 = 最小顶点覆盖

​                                                                                                                                                                                                                           

##### POJ3041 一个矩阵，某些位置有小行星，有一种炸弹，一次可以炸掉一行或者一列，现在问题是需要最少用多少这样的炸弹。                                                                                                                                                分析：行作为左顶点，列作为右顶点，若该行该列有交点，则连线，转化为求最小顶点覆盖

```c++
int main()
{
    scanf("%d %d", &n, &k);
    int x, y;
    for(int i = 1; i <= k; i++)
    {
        scanf("%d %d", &x, &y);
        add_edge(x, y);
    }

    for(int i = 1; i <= n; i++)
    {
        memset(vis, 0, sizeof(vis));
        if(dfs(i)) ans++;
    }
    printf("%d\n", ans);
}
```

##### POJ3216 一个r×c的牧场，有些地方有泥泞，有些地方有草，可以筑成水平或者竖直的墙(长度不限)，要求盖住所有泥泞，但不能盖住草，问最少建几做墙？                                                                                                  分析： 相比于之前的行列为左右点，可以一行连续的点作为一个序号，一列连续的点也成序号，这样一个泥泞可以得到行序号和列序号，如果连线，则这个问题就可以划归成最小顶点覆盖问题。



#### 在二分图中：最大独立集  = 顶点个数 – 最小顶点覆盖（最大匹配） 

##### 设最大匹配为m, 则最小顶点覆盖为m，去掉这个覆盖后，就不存在边，剩下的肯定是独立集，而因为这m个顶点各有一个匹配，这些匹配边不相连，想要成为一个独立集至少要去掉m个顶点。

##### 最大团：顶点都互相相连的最大顶点集合(二分图默认某一边都是互相连的)  二分图的最大团=补图的最大独立集



##### POJ3692 有一群男生女生，男生都相互认识，女生都相互认识，有k组关系来表示男生女生认识，现在要找最多的人出来，这些人相互认识                                                                                                                                                                        分析：找团比较困难，如果男生和女生之间不认识，就连线(补图)，这样将最大团转化为求最大独立集了

```c++
int main()
{
    int G, B, m, x, y, ans, cas = 1;
    while(~scanf("%d %d %d", &G, &B, &m) && G)
    {
        memset(head, -1, sizeof(head));        //初始化head为-1, tol为0
        tol = ans = 0;
        memset(mark, 0, sizeof(mark));
        memset(match, 0, sizeof(match));
        for(int i = 1; i <= m; i++)
        {
            scanf("%d %d", &x, &y);
            mark[x][y] = 1;
        }
        for(int i = 1; i <= G; i++)
            for(int j = 1; j <= B; j++)
                if(!mark[i][j])
                    add_edge(i, j);            //建立补图
        for(int i = 1; i <= G; i++)
        {
            memset(vis, 0, sizeof(vis));
            if(dfs(i)) ans++;
        }
        printf("case %d: %d\n", cas++, G + B - ans);
    }
}
```



#### 在二分图中，最小路径 =  顶点个数 - 最大匹配 = 最大独立集

##### 一个有向无环图，最大独立集的m个点互不相连，所以最短路径至少为m, 从这m个点出m条路径，如果还有点没有被覆盖，那么最大独立集就不是m了。

##### POJ2060 有很多人预订出租车，如果出租车做完一个任务能够敢到下一个任务，就不需要在调度一辆出租车了，现在请问最少需要几辆出租车。                                                                                                                                                                               分析： 假设有n个任务，每个任务为一个点，如果某个任务做完能到下一个任务，则两点连线，则就是求这个图的最小路径，假设一开始选的n条路径都只是单个点，如果没多一条连线，则路径数就会减1，则就是要求连线最多。如果把一个任务拆成两个点，如果任务A做完能到B，则左A到右B连线，这样求最多连线就转化为求最大匹配的问题了，答案就是n - 最大匹配

```c++
int main()
{
    int t, k, Hour, Minute, cnt, ans;
    scanf("%d", &t);
    while(t--)
    {
        memset(head, -1, sizeof(head));            //初始化
        memset(match, 0, sizeof(match));
        tol = cnt = ans = 0;
        scanf("%d", &k);
        for(int i = 1; i <= k; i++)
        {
            scanf("%d:%d %d %d %d %d", &Hour, &Minute, &pro[i].x1, &pro[i].y1, &pro[i].x2, &pro[i].y2);
            pro[i].start = Hour * 60 + Minute;
        }

        for(int i  = 1; i <= k; i++)              //建立边
            for(int j = 1; j <= k; j++)
                if(check(i, j))
                    add_edge(i, j);
        for(int i = 1; i <= k; i++)            //匈牙利算法求最大匹配
        {
            memset(vis, 0, sizeof(vis));
            if(dfs(i)) ans++;
        }
        printf("%d\n", k - ans);
    }
}
```

##### POJ 2594 一个有向无环图中， 有若干条连接的路线， 问最少放多少个机器人，可以将整个图上的点都走过(点可以重复)                                                                                                                                                                                                    分析：       ![img](https://pic002.cnblogs.com/images/2011/239942/2011073111520332.jpg)

##### 如果用最短路径算答案时3，但是实际是2，这时候需要先用floyd跑一遍传递闭包，让1和3,1和5,4和3有连线，这样在进行最短路径

```c++

void floyd()              
{
    for(int k = 1; k <= n; k++)                //K为中间节点
        for(int i = 1; i <= n; i++)
            if(d[i][k])                    //如果i和k可达
            for(int j = 1; j <= n; j++)
                if(d[k][j]) d[i][j] = 1;     //如果k和j可达
}

bool dfs(int x)
{
    for(int i = 1; i <= n; i++)
    {
        if(!vis[i] && d[x][i])              //如果x可达i并且i没有被访问
        {
            vis[i] = 1;
            if(!match[i] || dfs(match[i]))
            {
                match[i] = x;
                return true;
            }
        }
    }
    return false;
}

int main()
{
    int x, y, ans;
    while(~scanf("%d %d", &n, &m) && n)
    {
        memset(match, 0, sizeof(match));
        memset(d, 0, sizeof(d));
        ans = 0;
        for(int i = 1; i <= m; i++)
        {
            scanf("%d %d", &x, &y);
            d[x][y] = 1;
        }
        floyd();                              //先跑传递闭包
        for(int i = 1; i <= n; i++)           //再跑匈牙利算法
        {
            memset(vis, 0, sizeof(vis));
            if(dfs(i)) ans++;
        }
        printf("%d\n", n - ans);
    }
}
```

